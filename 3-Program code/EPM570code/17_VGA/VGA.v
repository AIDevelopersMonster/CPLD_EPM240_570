//*******************************************************//
//                       VGA DEMO                        //
//*******************************************************//
// Модуль     : VGA.v
// Устройство : CPLD / FPGA с тактовой частотой 50 МГц
// Created By : kontakts.ru
// Description: 
//   Пример формирования сигналов VGA 640x480 @ 60 Гц.
//   На экране выводятся цветные полосы по горизонтали и вертикали,
//   режим отображения выбирается переключателем switch[1:0]:
//     00 – вертикальные полосы (v_dat)
//     01 – горизонтальные полосы (h_dat)
//     10 – XOR вертикальных и горизонтальных полос (шахматный рисунок)
//     11 – XNOR вертикальных и горизонтальных полос (обратный шахматный)
//
//   Формируется:
//     - горизонтальная развертка (hcount)
//     - вертикальная развертка (vcount)
//     - активная область изображения (dat_act)
//     - сигналы синхронизации hsync и vsync
//     - 3-битный выход RGB (disp_RGB)
// Репозиторий проекта:  
// https://github.com/AIDevelopersMonster/CPLD_EPM240_570
//
// Плейлист FPGA/CPLD:  
// https://www.youtube.com/playlist?list=PLVoFIRfTAAI7-d_Yk6bNVnj4atUdMxvT5
//
//*******************************************************//

// Обучающий пример работы VGA: формирование развертки и тестового изображения

module VGA(
   clock,      // Входной системный тактовый сигнал 50 МГц
   switch,     // Переключатели режимов отображения (2 бита)
   disp_RGB,   // Выходные цветовые данные (3 бита: R,G,B)
   hsync,      // Горизонтальная синхронизация
   vsync       // Вертикальная синхронизация
);

input  clock;           // Системный клок 50 МГц
input  [1:0]switch;     // Переключатель режимов (4 варианта картинки)

output [2:0]disp_RGB;   // 3-битный цвет (каждый бит можно подать на R,G,B)
output  hsync;          // Импульс горизонтальной синхронизации
output  vsync;          // Импульс вертикальной синхронизации

// Счётчики строк и столбцов для VGA развертки
reg [9:0] hcount;       // Счётчик пикселей по горизонтали (0..799)
reg [9:0] vcount;       // Счётчик строк по вертикали (0..524)

// Временные регистры для формирования цветовых шаблонов
reg [2:0] data;         // Конечный цветовой код, выводимый на disp_RGB
reg [2:0] h_dat;        // Цвет, зависящий от номера строки (горизонтальные полосы)
reg [2:0] v_dat;        // Цвет, зависящий от номера столбца (вертикальные полосы)

// reg [9:0] timer;      // Счётчик времени (закомментирован, не используется)

reg   flag;             // Флаг для примера с timer (ниже закомментировано)
wire  hcount_ov;        // Флаг «конец строки»
wire  vcount_ov;        // Флаг «конец кадра»
wire  dat_act;          // Флаг «мы в активной области изображения»
wire  hsync;            // Провод для присвоения сигнала hsync
wire  vsync;            // Провод для присвоения сигнала vsync
reg   vga_clk;          // Пиксельный клок ~25 МГц (деление 50 МГц на 2)

// Параметры временных интервалов для VGA 640x480@60 Гц
// Все значения в тактах пиксельного клока (25 МГц)
parameter hsync_end   = 10'd95;   // Длительность импульса HSYNC
parameter hdat_begin  = 10'd143;  // Начало видимой области по горизонтали
parameter hdat_end    = 10'd783;  // Конец видимой области по горизонтали
parameter hpixel_end  = 10'd799;  // Полная длина строки (0..799)

parameter vsync_end   = 10'd1;    // Длительность импульса VSYNC
parameter vdat_begin  = 10'd34;   // Начало видимой области по вертикали
parameter vdat_end    = 10'd514;  // Конец видимой области по вертикали
parameter vline_end   = 10'd524;  // Полное число строк (0..524)

//=======================================================
// Делитель частоты: из 50 МГц делаем ~25 МГц для VGA
//=======================================================
always @(posedge clock)
begin
   vga_clk = ~vga_clk;  // На каждом фронте clock инвертируем vga_clk
end

//=======================================================
// Горизонтальная развертка (счётчик hcount)
//=======================================================
always @(posedge vga_clk)
begin
   if (hcount_ov)
      hcount <= 10'd0;                // Дошли до конца строки – начинаем сначала
   else
      hcount <= hcount + 10'd1;       // Иначе просто увеличиваем счётчик
end

// Условие конца строки
assign hcount_ov = (hcount == hpixel_end);

//=======================================================
// Вертикальная развертка (счётчик vcount)
//=======================================================
always @(posedge vga_clk)
begin
   if (hcount_ov)                     // Строку закончили – переходим к следующей
   begin
      if (vcount_ov)
         vcount <= 10'd0;             // Дошли до последней строки – начинаем новый кадр
      else
         vcount <= vcount + 10'd1;    // Иначе увеличиваем номер строки
   end
end

// Условие конца кадра
assign vcount_ov = (vcount == vline_end);

//=======================================================
// Активная область и сигналы синхронизации
//=======================================================

// dat_act = 1, когда луч в видимой части экрана
assign dat_act = ((hcount >= hdat_begin) && (hcount < hdat_end)) &&
                 ((vcount >= vdat_begin) && (vcount < vdat_end));

// Импульсы синхронизации (обычно активный уровень – низкий, здесь так и сделано):
// пока hcount <= hsync_end – hsync = 0, потом = 1
assign hsync = (hcount > hsync_end);
// пока vcount <= vsync_end – vsync = 0, потом = 1
assign vsync = (vcount > vsync_end);

// На выход disp_RGB подаем цвет только в активной зоне,
// вне активной области выводим «чёрный» цвет (000).
assign disp_RGB = (dat_act) ? data : 3'h0;

//=======================================================
// Формирование картинки (тестовые цветовые полосы)
//=======================================================

// Пример с таймером (закомментирован, при необходимости можно включить)
/*
always @(posedge vga_clk)
begin
   flag <= vcount_ov;
   if (vcount_ov && ~flag)
      timer <= timer + 1'b1;  // Увеличиваем таймер раз в кадр
end
*/

// Выбор источника данных data в зависимости от switch
always @(posedge vga_clk)
begin
   case (switch[1:0])
      2'd0: data <= h_dat;              // Режим 0: горизонтальные полосы
      2'd1: data <= v_dat;              // Режим 1: вертикальные полосы
      2'd2: data <= (v_dat ^ h_dat);    // Режим 2: XOR – шахматный рисунок
      2'd3: data <= (v_dat ~^ h_dat);   // Режим 3: XNOR – инвертированный шахматный рисунок
   endcase
end

//-------------------------------------------------------
// Формирование v_dat: вертикальные цветные полосы
// (цвет зависит от положения по горизонтали – hcount)
//-------------------------------------------------------
always @(posedge vga_clk)
begin
   if      (hcount < 223) v_dat <= 3'h7; // яркий цвет
   else if (hcount < 303) v_dat <= 3'h6;
   else if (hcount < 383) v_dat <= 3'h5;
   else if (hcount < 463) v_dat <= 3'h4;
   else if (hcount < 543) v_dat <= 3'h3;
   else if (hcount < 623) v_dat <= 3'h2;
   else if (hcount < 703) v_dat <= 3'h1;
   else                   v_dat <= 3'h0; // тёмный цвет
end

//-------------------------------------------------------
// Формирование h_dat: горизонтальные цветные полосы
// (цвет зависит от положения по вертикали – vcount)
//-------------------------------------------------------
always @(posedge vga_clk)
begin
   if      (vcount <  94) h_dat <= 3'h7;
   else if (vcount < 154) h_dat <= 3'h6;
   else if (vcount < 214) h_dat <= 3'h5;
   else if (vcount < 274) h_dat <= 3'h4;
   else if (vcount < 334) h_dat <= 3'h3;
   else if (vcount < 394) h_dat <= 3'h2;
   else if (vcount < 454) h_dat <= 3'h1;
   else                   h_dat <= 3'h0;
end

endmodule
