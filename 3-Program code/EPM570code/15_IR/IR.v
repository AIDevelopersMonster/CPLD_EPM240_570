/*
  Module     : IR.v
  Device     : Инфракрасный приёмник (NEC protocol, VS1838 / HX1838)
  Created By : kontakts.ru
  Description:
    Модуль приёма команд от ИК-пульта (протокол NEC) и отображения цифры
    на 7-сегментном индикаторе.

    Функции модуля:
      - Синхронизация входного сигнала IR и формирование импульсов
        irda_pos_pulse / irda_neg_pulse.
      - Измерение длительности импульсов NEC (start 9 ms, pause 4.5 ms,
        короткий импульс «0», длинный импульс «1»).
      - Реализация конечного автомата состояний:
            IDLE → LEADER_9 → LEADER_4 → DATA_STATE → IDLE
      - Приём 32-битного кадра NEC в сдвиговый регистр get_data.
      - Разбор принятого кадра на 4 байта (led1..led4).
      - Декодирование второго байта (led2) в цифру 0–9.
      - Вывод кода сегментов на led_db.
      - Неизвестный код отображается как символ "F".

    Использование:
      - clk        — системная частота (например, 50 МГц).
      - rst_n      — асинхронный сброс (0 = сброс).
      - IR         — цифровой выход ИК-приёмника.
      - led_cs     — выбор разряда 7-сегментного индикатора.
      - led_db     — сегменты индикатора (a,b,c,d,e,f,g,dp).

    Дополнительно:
      - Пример архитектуры real-time декодирования протокола NEC.
      - Подходит для демонстрации на платах EPM240 / EPM570.

    Проект CPLD / FPGA:
      GitHub   : https://github.com/AIDevelopersMonster/CPLD_EPM240_570
      YouTube  : https://www.youtube.com/playlist?list=PLVoFIRfTAAI7-d_Yk6bNVnj4atUdMxvT5
*/


module IR(
    clk,        // системный тактовый сигнал (например, 50 МГц)
    rst_n,      // асинхронный сброс, активный низким уровнем
    IR,         // вход от ИК-приёмника (цифровой сигнал)
    led_cs,     // выбор разряда индикатора (анод/катод, 4 бита)
    led_db      // шина сегментов 7-сегментного индикатора (8 бит, включая точку)
);

  input   clk;
  input   rst_n;
  input   IR;
  output [3:0] led_cs;
  output [7:0] led_db;
 
  reg [3:0] led_cs;
  reg [7:0] led_db;
 
  // 4 байта принятого кадра (адрес, инверсии и т.д.) — пока почти не используются
  reg [7:0] led1,led2,led3,led4;

  reg [15:0] irda_data;    // зарезервировано под 16 бит данных (в этой версии не используется)
  reg [31:0] get_data;     // сдвиговый регистр для хранения 32 бит ИК-кадра
  reg [5:0]  data_cnt;     // счётчик принятых бит (до 32)
  reg [2:0]  cs,ns;        // текущий и следующий состояния автомата
  reg error_flag;          // флаг ошибки приёма (ошибка длительности импульса и т.п.)

  // ---------------------------------------------------------------------------
  // Триггеры для "очистки" сигнала от дребезга/метастабильности
  // и выделения фронтов сигнала IR

  reg irda_reg0;       // первый регистр синхронизации сигнала IR
  reg irda_reg1;       // второй регистр синхронизации
  reg irda_reg2;       // третий регистр (для выделения фронтов)

  wire irda_neg_pulse; // одиночный импульс при отрицательном фронте IR
  wire irda_pos_pulse; // одиночный импульс при положительном фронте IR
  wire irda_chang;     // любой перепад сигнала IR (любое изменение уровня)
  
  // Счётчик для (пока) "заглушки" под сканирование индикатора
  reg [15:0] cnt_scan;
   
  // Синхронизация входа и первичная инициализация
  always @ (posedge clk)
    if(!rst_n) begin
        irda_reg0 <= 1'b0;
        irda_reg1 <= 1'b0;
        irda_reg2 <= 1'b0;
        led_cs    <= 4'b0000;   // по умолчанию все разряды выключены
    end
    else begin
        led_cs    <= 4'b0000;   // пока все разряды индикатора в одном состоянии
        irda_reg0 <= IR;
        irda_reg1 <= irda_reg0;
        irda_reg2 <= irda_reg1;
    end
     
  // Фронты и изменение сигнала
  assign irda_neg_pulse =  irda_reg2 & (~irda_reg1); // отрицательный фронт IR
  assign irda_pos_pulse = (~irda_reg2) &  irda_reg1; // положительный фронт IR
  assign irda_chang     = irda_neg_pulse | irda_pos_pulse;

  // ---------------------------------------------------------------------------
  // Таймеры для измерения длительности импульсов/пауз ИК-сигнала (NEC протокол)

  reg [10:0] counter;  // делитель тактовой частоты (до 1750)
  reg [8:0]  counter2; // счётчик периодов делителя — фактически измеритель времени

  wire check_9ms;  // проверка длительности стартового импульса ~9 мс
  wire check_4ms;  // проверка длительности паузы ~4.5 мс
  wire low;        // интервал, соответствующий логическому "0"
  wire high;       // интервал, соответствующий логической "1"
 
  // Делитель: считает до 1750, затем сбрасывается.
  // При каждом изменении уровня IR счётчик сбрасывается, чтобы "начать измерение заново".
  always @ (posedge clk)
    if (!rst_n)
      counter <= 11'd0;
    else if (irda_chang)       // если уровень IR изменился — сброс счётчика
      counter <= 11'd0;
    else if (counter == 11'd1750)
      counter <= 11'd0;
    else
      counter <= counter + 1'b1;
  
  // Счётчик времени: увеличивается, когда делитель дошёл до 1750
  always @ (posedge clk)
    if (!rst_n)
      counter2 <= 9'd0;
    else if (irda_chang)       // при изменении уровня IR — сброс измерения
      counter2 <= 9'd0;
    else if (counter == 11'd1750)
      counter2 <= counter2 + 1'b1;
  
  // Окна допусков по длительности (значения подогнаны под конкретную частоту clk)
  assign check_9ms = ((217 < counter2) & (counter2 < 297)); // окно вокруг 9 мс
  assign check_4ms = ((88  < counter2) & (counter2 < 168)); // окно вокруг 4.5 мс
  assign low       = ((6   < counter2) & (counter2 < 26));  // "короткий" импульс (лог.0)
  assign high      = ((38  < counter2) & (counter2 < 58));  // "длинный" импульс (лог.1)

  // ---------------------------------------------------------------------------
  // Автомат состояний приёма NEC-кадра

  parameter IDLE       = 3'b000, // ожидание начала посылки
            LEADER_9   = 3'b001, // измеряем стартовый импульс ~9 мс
            LEADER_4   = 3'b010, // измеряем паузу ~4.5 мс
            DATA_STATE = 3'b100; // принимаем 32 бита данных
 
  // Регистр текущего состояния
  always @ (posedge clk)
    if (!rst_n)
      cs <= IDLE;
    else
      cs <= ns;
     
  // Комбинаторика переходов по состояниям
  always @ (*) begin
    case (cs)
      IDLE: begin
        // Ждём перехода сигнала в "0" (начало стартового импульса)
        if (~irda_reg1)
          ns = LEADER_9;
        else
          ns = IDLE;
      end

      LEADER_9: begin
        // Стартовый импульс закончился по положительному фронту
        if (irda_pos_pulse) begin
          if (check_9ms)
            ns = LEADER_4;  // длительность в норме — ждём паузу
          else
            ns = IDLE;      // ошибка по времени — сброс
        end
        else
          ns = LEADER_9;
      end

      LEADER_4: begin
        // Ждём отрицательный фронт после паузы ~4.5 мс
        if (irda_neg_pulse) begin
          if (check_4ms)
            ns = DATA_STATE; // всё ок — начинаем приём данных
          else
            ns = IDLE;       // ошибка по времени
        end
        else
          ns = LEADER_4;
      end

      DATA_STATE: begin
        // Приём 32 бит данных.
        // Выходим в IDLE либо по ошибке, либо когда все 32 бита приняты и линия "1".
        if ((data_cnt == 6'd32) & irda_reg2 & irda_reg1)
          ns = IDLE;
        else if (error_flag)
          ns = IDLE;
        else
          ns = DATA_STATE;
      end

      default: ns = IDLE;
    endcase
  end

  // ---------------------------------------------------------------------------
  // Логика приёма бит данных в состоянии DATA_STATE

  always @ (posedge clk)
    if (!rst_n) begin
      data_cnt   <= 6'd0;
      get_data   <= 32'd0;
      error_flag <= 1'b0;
    end  
    else if (cs == IDLE) begin
      // При выходе в IDLE всё обнуляем
      data_cnt   <= 6'd0;
      get_data   <= 32'd0;
      error_flag <= 1'b0;
    end  
    else if (cs == DATA_STATE) begin
      // Контроль наличия "короткого" импульса 0.56 мс (общая часть для 0 и 1)
      if (irda_pos_pulse) begin
        if (!low)          // длительность не попала в окно — ошибка
          error_flag <= 1'b1;
      end
      // По отрицательному фронту определяем, был "0" или "1"
      else if (irda_neg_pulse) begin
        if (low)
          get_data[0] <= 1'b0;  // короткий импульс — лог.0
        else if (high)
          get_data[0] <= 1'b1;  // длинный импульс — лог.1
        else
          error_flag <= 1'b1;   // длительность "мимо" — ошибка
             
        // Сдвиг регистра: новый бит заходит в младший разряд
        get_data[31:1] <= get_data[30:0];
        data_cnt       <= data_cnt + 1'b1;
      end
    end

  // ---------------------------------------------------------------------------
  // Разбор принятого 32-битного слова по байтам
  // Обычно NEC: [адрес][~адрес][данные][~данные]

  always @ (posedge clk)
    if (!rst_n)
      irda_data <= 16'd0;
    else if ((data_cnt == 6'd32) & irda_reg1) begin
      led1 <= get_data[7:0];    // младший байт
      led2 <= get_data[15:8];   // следующий байт (по нему выбирается цифра)
      led3 <= get_data[23:16];  // пользовательские данные
      led4 <= get_data[31:24];  // старший байт
    end
 
  // ---------------------------------------------------------------------------
  // Отображение нажатой кнопки ПДУ на 7-сегментном индикаторе
  // По коду led2 выбирается, какую цифру показывать (0–9).
  // Если код неизвестен — отображается буква 'F'.

  always @(led2) begin
    case (led2)
        // Ниже — конкретные коды кнопок ИК-пульта (scan-code),
        // подобранные под конкретный пульт.

        8'b0110_1000: // код кнопки "0"
            led_db = 8'b1100_0000;  // отображать "0"

        8'b0011_0000: // код кнопки "1"
            led_db = 8'b1111_1001;  // "1"

        8'b0001_1000: // код кнопки "2"
            led_db = 8'b1010_0100;  // "2"

        8'b0111_1010: // код кнопки "3"
            led_db = 8'b1011_0000;  // "3"

        8'b0001_0000: // код кнопки "4"
            led_db = 8'b1001_1001;  // "4"

        8'b0011_1000: // код кнопки "5"
            led_db = 8'b1001_0010;  // "5"

        8'b0101_1010: // код кнопки "6"
            led_db = 8'b1000_0010;  // "6"

        8'b0100_0010: // код кнопки "7"
            led_db = 8'b1111_1000;  // "7"

        8'b0100_1010: // код кнопки "8"
            led_db = 8'b1000_0000;  // "8"

        8'b0101_0010: // код кнопки "9"
            led_db = 8'b1001_0000;  // "9"
            
        // Если код не распознан — показываем 'F'
        default:
            led_db = 8'b1000_1110;  // символ "F"
    endcase
  end

endmodule
