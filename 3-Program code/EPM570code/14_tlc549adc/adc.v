/*
  Module     : adc.v
  Device     : TLC549 (8-битный последовательный АЦП)
  Created By : kontakts.ru
  Description: 
    Контроллер для 8-битного АЦП TLC549.

    Функции модуля:
    - Формирует тактовый сигнал adc_clk для TLC549 (делитель от системного clock).
    - Управляет сигналом cs_n (выбор кристалла, старт/стоп преобразования).
    - При включении enable запускает цикл измерения:
        1) Пауза с активным cs_n для подготовки АЦП (adc_ready).
        2) Чтение 8-битного последовательного кода с вывода sdat_in (adc_receive).
        3) Ожидание завершения преобразования (adc_conversion).
        4) Пересылка полученного байта в data_out и установка флага data_ready (adc_data_load).
    - data_ready выдаёт одиночный импульс, когда в data_out появляется новое значение.

    Использование:
      - clock      — системная частота (например, 50 МГц).
      - reset      — синхронный сброс (1 = сброс).
      - enable     — запуск одного цикла измерения.
      - sdat_in    — серийный выход данных TLC549.
      - adc_clk    — тактовый сигнал для АЦП.
      - cs_n       — сигнал выбора кристалла (активен низким уровнем).
      - data_out   — принятые 8 бит результата.
      - data_ready — импульс “данные готовы”.
*/

module adc(
    clock,       // системный тактовый сигнал
    reset,       // сброс, активный высоким уровнем
    enable,      // разрешение/запуск преобразования
    sdat_in,     // последовательные данные от TLC549
    adc_clk,     // тактирование TLC549
    cs_n,        // выбор микросхемы TLC549 (active low)
    data_ready,  // флаг наличия новых данных
    data_out     // параллельный 8-битный результат АЦП
);  

// I/O сигналы
input       clock;          	    // системный тактовый сигнал
input       reset;          	    // сброс, высокий уровень = активен
input       enable;			    // запуск цикла преобразования
input       sdat_in;			    // последовательные данные от TLC549

output      adc_clk;			    // тактовый сигнал для TLC549
output      cs_n;				    // выбор кристалла TLC549 (active low)
output      data_ready;			// импульс – есть новые данные
output[7:0] data_out;			    // 8-битный результат АЦП

// Регистры для вывода на ноги
reg         adc_clk_r;             // внутренний регистр такта АЦП
reg         cs_n_r;                // регистр сигнала выборки
reg         data_ready_r;          // регистр флага готовности данных
reg  [7:0]  data_out_r;			// регистр для результата АЦП
reg         sdat_in_r;			    // синхронизированная версия sdat_in

// Внутренние регистры
reg  [7:0]  q;					    // сдвиговый регистр для приёма 8-битного слова
reg  [2:0]  adc_state;     		// текущий состояние автомата
reg  [2:0]  adc_next_state;        // следующее состояние автомата
reg  [5:0]  bit_count;       		// счётчик отсчётов/бит
reg         bit_count_rst;			// сброс счётчика bit_count
reg         div_clk;               // делитель тактов – “тик” для bit_count
reg  [CLK_DIV_BITS-1:0] clk_count; // счётчик для формирования div_clk

reg         buf1, buf2;            // двухтактный буфер для детектора фронта adc_clk_r

// Внутренние флаги
wire        ready_done;			// окончание подготовительного интервала cs_n
wire        rec_done;			// окончание приёма данных
wire        conv_done;			// окончание полного цикла преобразования

// ------------------------------------------------------------
// Параметры делителя частоты для adc_clk
// ------------------------------------------------------------
// CLK_DIV_VALUE определяет период возникновения импульса div_clk.
// При каждом div_clk == 1 выполняется инкремент bit_count, а также
// выполняется логика, связанная со сменой этапов.
parameter CLK_DIV_VALUE = 31;  // делитель для формирования div_clk
parameter CLK_DIV_BITS  = 5;   // разрядность счётчика clk_count

// ------------------------------------------------------------
// Описания состояний автомата состояния АЦП
// ------------------------------------------------------------
// idle            — ожидание enable, cs_n=1, сброшен счётчик
// adc_ready       — выдержка времени перед чтением (cs_n=0)
// adc_receive     — активное чтение 8 бит данных с sdat_in
// adc_conversion  — ожидание окончания аналогового преобразования
// adc_data_load   — перенос принятого слова в data_out и флаг data_ready
parameter   idle            = 3'b000,
            adc_ready       = 3'b001,
            adc_receive     = 3'b011,
            adc_conversion  = 3'b010,
            adc_data_load   = 3'b110;
			
//**********************************************************
// Присвоение внутренних регистров внешним выводам
//**********************************************************
assign adc_clk    = adc_clk_r;
assign cs_n       = cs_n_r;
assign data_out   = data_out_r;
assign data_ready = data_ready_r;

//**********************************************************
// Синхронизация входа sdat_in по такту clock
//**********************************************************
always @(posedge clock)
begin
    sdat_in_r <= sdat_in;          // защита от метастабильности
end

//**********************************************************
// Делитель частоты: формирование импульса div_clk
//**********************************************************
always @(posedge clock)
begin
	if (reset == 1'b1)           
	begin
		clk_count <= {CLK_DIV_BITS{1'b0}};
		div_clk   <= 1'b0;
	end
	else
	begin
		if (clk_count < CLK_DIV_VALUE)
 	    begin
 	    	clk_count <= clk_count + 1'b1;
 	    	div_clk   <= 1'b0;  // пока счётчик не достиг предела, div_clk=0
 	    end
 	    else
 	    begin
 	    	clk_count <= {CLK_DIV_BITS{1'b0}}; // сброс счётчика
 	    	div_clk   <= 1'b1; // однотактный импульс
 	    end
 	end
end

//**********************************************************
// Регистровая часть автомата состояний АЦП
//**********************************************************
always @(posedge clock)
begin 
    if (reset == 1'b1) 
		adc_state <= idle;     // при сбросе всегда в idle
    else 
		adc_state <= adc_next_state;
end

//**********************************************************
// Комбин. логика переходов автомата АЦП
//**********************************************************
always @(adc_state or ready_done or rec_done or conv_done or enable)
begin 
    // значения по умолчанию
	cs_n_r        <= 1'b0;
	bit_count_rst <= 1'b0;
	data_ready_r  <= 1'b0;
	
	case (adc_state)
	    
        // ---------------- IDLE ----------------
	    idle:                 					// начальное состояние
	    begin
			cs_n_r        <= 1'b1;              // АЦП не выбран
			bit_count_rst <= 1'b1;				// сбрасываем счётчик бит/тактов
			
	        if (enable == 1'b1)                 // как только enable = 1
				adc_next_state <= adc_ready;    // переходим к подготовке
	        else
				adc_next_state <= idle;
	    end
	      
        // ---------------- ADC_READY ----------------
	    adc_ready:  							// подготовительный интервал
	    begin
			if (ready_done == 1'b1)             // выдержали нужное число тактов
	       	 	adc_next_state <= adc_receive;  // переходим к приёму
			else 
				adc_next_state <= adc_ready;
	    end
	
        // ---------------- ADC_RECEIVE ----------------
	    adc_receive:  							// приём последовательных данных
	    begin
			if (rec_done == 1'b1)               // считаны все нужные биты
	       	 	adc_next_state <= adc_conversion;// ждём завершения преобразования
			else 
				adc_next_state <= adc_receive;
	    end

        // ---------------- ADC_CONVERSION ----------------
		adc_conversion:							// ожидание конца преобразования
		begin
			cs_n_r <= 1'b1;                     // отпускаем АЦП (по даташиту)
			
			if (conv_done == 1'b1)              // по истечении нужного времени
	       	 	adc_next_state <= adc_data_load;
			else 
				adc_next_state <= adc_conversion;
		end 
		
        // ---------------- ADC_DATA_LOAD ----------------
		adc_data_load:                         // фиксация результата
		begin
			data_ready_r   <= 1'b1;				// импульс — “данные готовы”
			adc_next_state <= idle;             // возвращаемся в ожидание
		end
	
	    default : adc_next_state <= idle;
    endcase
end

//**********************************************************
// Счётчик bit_count, “привязанный” к div_clk
//**********************************************************
always @(posedge clock)
begin
    if (reset == 1'b1)
		bit_count <= 6'd0;  
    else if (bit_count_rst == 1'b1) 
		bit_count <= 6'd0; 
	else if (div_clk == 1'b1)
    	bit_count <= bit_count + 1'b1; // увеличиваем только на импульс div_clk
end

// Флаги этапов по значению bit_count
assign ready_done = (bit_count == 6'd4);	// окончание подготовительного интервала	
assign rec_done   = (bit_count == 6'd19);	// окончание приёма данных
assign conv_done  = (bit_count == 6'd63);	// окончание полного цикла преобразования

//**********************************************************
// Формирование adc_clk_r по bit_count
// В промежутке 4..19 генерируем псевдотакт для чтения данных.
//**********************************************************
always @(bit_count)
begin
	if ((bit_count < 6'd20) && (bit_count >= 6'd4))
		adc_clk_r <= ~bit_count[0];   // тактовый сигнал с половинным периодом от div_clk
	else
		adc_clk_r <= 1'b0;            // вне окна приёма adc_clk = 0
end

//**********************************************************
// Детектор фронта adc_clk_r (buf1/buf2)
//**********************************************************
always @(posedge clock)
begin
	buf1 <= adc_clk_r;
	buf2 <= buf1;
end

//**********************************************************
// Сдвиговый регистр чтения данных q
//**********************************************************
always @(posedge clock)
begin
	// по восходящему фронту adc_clk_r (buf1=1, buf2=0)
	if (buf1 && ~buf2)							
		q <= {q[6:0], sdat_in_r};    // сдвиг влево, младший бит заходит с sdat_in
	else if (data_ready_r == 1'b1)  // по завершению цикла – фиксируем результат
		data_out_r <= q;
end

endmodule
